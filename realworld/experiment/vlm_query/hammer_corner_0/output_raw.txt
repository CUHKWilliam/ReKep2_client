```python
### <stage constraints splitter> ###
### stage 1 sub-goal constraints (grasping the hammer)
def stage_1_subgoal_constraint1():
    """constraints: <"grasp", "the area of the handle of the hammer"> """
    return grasp("the area of the handle of the hammer")


### <stage constraints splitter> ###
### stage 2 sub-goal constraints (aligning the hammer with the black nail)
def stage_2_subgoal_constraint1():
    """constraints: <"sub-goal constraints", "the center of the head of the hammer", "the axis of the body of the black nail", "the center of the head of the hammer is colinear with the axis of the body of the black nail by 10 centimeters">"""
    mask1 = segment("the center of the head of the hammer", -1)
    mask2 = segment("the axis of the body of the black nail", -1)
    
    if mask1.shape[-1] == 3:
        pc1 = mask1
        pc2 = mask2
    else:
        pc1 = mask_to_pc(mask1)
        pc2 = mask_to_pc(mask2)

    # Calculate the center of the head of the hammer
    hammer_head_center = np.mean(pc1, axis=0)
    
    # Calculate the axis of the black nail
    covariance_matrix_nail = np.cov(pc2.T)
    eigenvalues_nail, eigenvectors_nail = np.linalg.eig(covariance_matrix_nail)
    nail_axis = eigenvectors_nail[:, np.argmax(eigenvalues_nail)]
    nail_axis = nail_axis / np.linalg.norm(nail_axis)

    # Calculate the target point 10 cm along the axis of the black nail
    nail_center = np.mean(pc2, axis=0)
    target_point = nail_center + nail_axis * 0.1

    # Calculate the cost as the L2 distance between the hammer head center and the target point
    cost = np.linalg.norm(hammer_head_center - target_point)
    
    return cost

def stage_2_subgoal_constraint2():
    """constraints: <"sub-goal constraints", "the axis of the handle of the hammer", "the axis of the body of the black nail", "the axis of the handle of the hammer is parallel to the axis of the body of the black nail">"""
    mask1 = segment("the axis of the handle of the hammer", -1)
    mask2 = segment("the axis of the body of the black nail", -1)
    
    if mask1.shape[-1] == 3:
        pc1 = mask1
        pc2 = mask2
    else:
        pc1 = mask_to_pc(mask1)
        pc2 = mask_to_pc(mask2)

    # Calculate the axis of the handle of the hammer
    covariance_matrix_hammer = np.cov(pc1.T)
    eigenvalues_hammer, eigenvectors_hammer = np.linalg.eig(covariance_matrix_hammer)
    hammer_axis = eigenvectors_hammer[:, np.argmax(eigenvalues_hammer)]
    hammer_axis = hammer_axis / np.linalg.norm(hammer_axis)

    # Calculate the axis of the black nail
    covariance_matrix_nail = np.cov(pc2.T)
    eigenvalues_nail, eigenvectors_nail = np.linalg.eig(covariance_matrix_nail)
    nail_axis = eigenvectors_nail[:, np.argmax(eigenvalues_nail)]
    nail_axis = nail_axis / np.linalg.norm(nail_axis)

    # Calculate the cost as the angle between the two axes
    dot_product = np.dot(hammer_axis, nail_axis)
    cost = abs(1 - dot_product) * 5  # Multiply by 5 for angle constraints
    
    return cost


### <stage constraints splitter> ###
### stage 3 target constraints (smashing the black nail)
def stage_3_target_constraint1():
    """constraints: <"target constraints", "the center of the head of the hammer", "the center of the body of the black nail", "the center of the head of the hammer moves toward the center of the body of the black nail by 5 centimeters">"""
    mask1 = segment("the center of the head of the hammer", -1)
    mask2 = segment("the center of the body of the black nail", -1)
    
    if mask1.shape[-1] == 3:
        pc1 = mask1
        pc2 = mask2
    else:
        pc1 = mask_to_pc(mask1)
        pc2 = mask_to_pc(mask2)

    # Calculate the center of the head of the hammer
    hammer_head_center = np.mean(pc1, axis=0)
    
    # Calculate the center of the body of the black nail
    nail_center = np.mean(pc2, axis=0)

    # Calculate the target point 5 cm along the axis of the black nail
    direction_vector = nail_center - hammer_head_center
    direction_vector = direction_vector / np.linalg.norm(direction_vector)
    target_point = hammer_head_center + direction_vector * 0.05

    # Calculate the cost as the L2 distance between the hammer head center and the target point
    cost = np.linalg.norm(hammer_head_center - target_point)
    
    return cost


### <stage constraints splitter> ###
### stage 4 sub-goal constraints (releasing the hammer)
def stage_4_subgoal_constraint1():
    """constraints: <"release"> """
    release()
    return


### List of `geometry` of `the object part` of `the object` to track:
object_to_segment = [
    "the area of the handle of the hammer",
    "the center of the head of the hammer",
    "the axis of the handle of the hammer",
    "the axis of the body of the black nail",
    "the center of the body of the black nail"
]
```